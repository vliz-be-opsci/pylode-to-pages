#!/usr/bin/env -S python3 -B

# NOTE: If you are using an alpine docker image
# such as pyaction-lite, the -S option above won't
# work. The above line works fine on other linux distributions
# such as debian, etc, so the above line will work fine
# if you use pyaction:4.0.0 or higher as your base docker image.

import sys
import os
import shutil
import logging
import logging.config
import yaml
from dotenv import load_dotenv
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, BaseLoader
from pylode import OntDoc, PylodeError, __version__ as plv
from pylode import (
    DCTERMS,
    OWL,
    PROF,
    RDF,
    SKOS,
)
from itertools import chain


log = logging.getLogger('pylode-to-pages')


EMBEDDED_YAML_LOGCONF = """
version: 1
formatters:
  base:
    format: '%(asctime)-18s @%(name)-20s [%(levelname)-8s] %(message)s'
    datefmt: '%Y-%m-%d %H:%M:%S'
handlers:
  stderr:
    class: logging.StreamHandler
    level: DEBUG
    formatter: base
    stream: ext://sys.stderr
loggers:
  pylode-to-pages:
    level: DEBUG
root:
  level: DEBUG
  handlers: [stderr]
"""


EMBEDDED_INDEX_TEMPLATE = """
<html>
<head>
  <title>Overview of {{baseuri}} namespace</title>
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
        crossorigin="anonymous">
</head>
<body class="container">
<h1>Overview of described vocabularies in <a href="{{baseuri}}">this namespace</a>.</h1>

<table class="table table-bordered table-hover table-striped">
  <thead class="thead-dark"><tr>
    <th>Linked Name</th><th>Description</th><th>Last modified</th>
  </tr></thead>
  <tbody>
    {%for key,onto in ontos.items()%}
      <tr><td><a href="{{onto.relref}}">{{onto.name}}/</a></td><td>{{onto.title}}</td><td>{{onto.lastmod}}</td></tr>
    {%endfor %}
  </tbody>
</table>
<div class="footer text-center">Generated by <a href="https://github.com/vliz-be-opsci/pylode-to-pages">pylode-to-pages</a></div>
</body>
</html>
"""


def enable_logging(logconf):
    if logconf is not None and Path(logconf).is_file():
        with open(logconf, 'r') as yml_logconf:
            logging.config.dictConfig(yaml.load(yml_logconf, Loader=yaml.SafeLoader))
    else:
        logging.config.dictConfig(yaml.load(EMBEDDED_YAML_LOGCONF, Loader=yaml.SafeLoader))
        log.warning(f"logconf file '{logconf}' does not exist. Embedded logging config applied as fallback.")


def extract_pub_dict(od: OntDoc):
    def ont_prop(ont, predicate):
        value = None
        for s in chain(
            ont.subjects(RDF.type, OWL.Ontology),
            ont.subjects(RDF.type, PROF.Profile),
            ont.subjects(RDF.type, SKOS.ConceptScheme),
        ):
            for obj in ont.objects(s, predicate):
                value = str(obj)
        return value

    def od_title():
        return ont_prop(od.ont, DCTERMS.title)

    def od_lastmod():
        return ont_prop(od.ont, DCTERMS.modified)

    return dict(title=od_title(), lastmod=od_lastmod())


def ontopub(baseuri, nsfolder, nssub, nsname, outfolder):
    log.debug(f"ontology to process: {nssub}/{nsname} in {nsfolder}")

    nsfolder = Path(nsfolder)
    outfolder = Path(outfolder)
    nspath = (nsfolder / nssub / nsname).resolve()
    outpath = (outfolder / nssub / nsname).resolve()
    outbackpath = (outfolder / nssub / f"{nsname}.bak").resolve()

    # extract name for {{ self }} from filename
    name = str(Path(nsname).stem)
    # produce html path and index-path
    outhtmlpath = (outfolder / nssub / f"{name}.html").resolve()
    log.debug(f"> {name} --> outhtmlpath == '{outhtmlpath}'")
    outindexpath = (outfolder / nssub / name).resolve() / "index.html"
    log.debug(f"> {name} --> outindexpath == '{outindexpath}'")

    # and finally prefix it with the nssub if relevant to produce the jinja {{name}}
    name = name if str(nssub) == '.' else str(nssub) + "/" + name
    log.debug(f"> {name} --> ontopub work started")

    # ensure outfolder exists (indexpath is the deepest one)
    os.makedirs(outindexpath.parent, exist_ok=True)
    log.debug(f"> {name} --> created folders to contain '{outindexpath}'")
    # make a backup
    shutil.copyfile(nspath, outbackpath)
    log.debug(f"> {name} --> backup original provided at '{outbackpath}'")

    # apply jinja2 (building context with baseuri and self) -- build jinja2 context - execute
    prms = dict(name=name, baseuri=baseuri)
    templates_env = Environment(loader=FileSystemLoader(nsfolder))
    template = templates_env.get_template(str(nspath.relative_to(nsfolder)))
    outcome = template.render(prms)
    log.debug(f"> {name} --> context for templates == {prms}")
    with open(str(outpath), "w") as outfile:
        outfile.write(outcome)
    log.debug(f"> {name} --> processed ontlogy written to '{outpath}'")

    nspub = dict(error=True)  # this assumes things will go bad :)
    try:                      # apply pylode
        od = OntDoc(outpath)
        log.debug(f"> {name} --> ontology loaded to pylode from '{outpath}'")
        # ask pylode to make the html
        od.make_html(destination=outhtmlpath, include_css=False)
        log.debug(f"> {name} --> html produced to '{outhtmlpath}'")
        # also add an extra copy from name.html to name/index.html AND for the css as well
        shutil.copy(outhtmlpath, outindexpath)
        shutil.copy(outhtmlpath.parent / "pylode.css", outindexpath.parent / "pylode.css")
        log.debug(f"> {name} --> copy added to '{outindexpath}'")
        # get some minimal metadata from the ttl since pylode loaded that into memory anyway?
        nspub = extract_pub_dict(od)  # if we got here however, things should be ok
        log.debug(f"> {name} --> ready with result == {nspub}")
        nspub['name'] = name
        nspub['relref'] = outindexpath.parent.relative_to(outfolder)
    except PylodeError as ple:
        log.error(f"> {name} --> pylode v.{plv} failed to process ontology at '{nspath}'")
        log.exception(ple)
    except Exception as e:
        log.error(f"> {name} -->  unexpected failure in processing ontology at '{nspath}'")
        log.exception(e)
    finally:
        # return the pub struct with core elements for the overview page
        log.debug(f"> {name} --> returning result == {nspub}")
        return nspub


def publish_misc(baseuri, nsfolder, outfolder ):
    otherfiles = ["CNAME"]
    nsfolder = Path(nsfolder)
    outfolder = Path(outfolder)
    for other in otherfiles:
        otherfile = nsfolder / other
        if otherfile.exists():
            shutil.copy(otherfile, outfolder / other)
    #TODO consider generating CNAME file with content derived from baseuri


def publish_ontologies(baseuri, nsfolder, outfolder, logconf=None):
    enable_logging(logconf)

    # default target folder to input folder
    outfolder = nsfolder if outfolder is None else outfolder
    outfolder = Path(outfolder).resolve()
    nsfolder = Path(nsfolder).resolve()
    log.debug(f"publishing ontologies from '{nsfolder}' to '{outfolder}' while applying baseuri={baseuri}")

    # init result sets
    ontos = dict()
    ontos_in_err = set()

    # run over nsfolder and process ontology files
    for folder, dirs, nsfiles in os.walk(nsfolder, topdown=False, followlinks=True):
        for nsname in nsfiles:
            if nsname.endswith('.ttl'):
                log.debug(f"ttl file at {folder} - {nsname} when walking {nsfolder}")
                nssub = Path(folder).relative_to(nsfolder)
                nskey = f"{str(nssub)}/{nsname}"
                nspub = ontopub(baseuri, nsfolder, nssub, nsname, outfolder)
                if bool(nspub.get("error")):  # if the error key is there and set to anything non-False
                    log.debug(f"error processing {nskey} --> {nspub}")
                    ontos_in_err.add(nskey)
                ontos[nskey] = nspub

    # copy any other stuff outside the actual pylode / ontology stuff 
    publish_misc(baseuri, nsfolder, outfolder)

    # generate a proper index.html file using an embedded jinja-template
    prms = dict(ontos=ontos, baseuri=baseuri)
    templates_env = Environment(loader=BaseLoader)
    template = templates_env.from_string(EMBEDDED_INDEX_TEMPLATE)
    outcome = template.render(prms)
    log.debug(f"> INDEX --> context for template == {prms}")
    outindexpath = outfolder / "index.html"
    with open(str(outindexpath), "w") as outfile:
        outfile.write(outcome)
    log.debug(f"> INDEX --> overview of processed ontologies written to '{outindexpath}'")

    if len(ontos_in_err) > 0:
        raise OntoPubException(ontos, ontos_in_err)
    # else
    return ontos


class OntoPubException(Exception):
    def __init__(self, ontos: dict, error_ontos: set):
        self.ontos = ontos
        self.error_ontos = error_ontos
        self.message = f"failed to produce all {len(error_ontos)} out of {len(ontos)} found"
        super().__init__(self.message)


def main():
    load_dotenv()

    # read the action inputs
    baseuri = sys.argv[1] if len(sys.argv) > 1 else os.environ.get('BASE_URI')
    nsfolder = sys.argv[2] if len(sys.argv) > 2 else "."
    outfolder = sys.argv[3] if len(sys.argv) > 3 else None
    logconf = sys.argv[4] if len(sys.argv) > 4 else os.environ.get('LOGCONF')

    # do the actual work
    # TODO consider some way to deal with the possible OntoPubException
    ontos = publish_ontologies(baseuri, nsfolder, outfolder, logconf)

    # set the action outputs
    print(f"::set-output name=ontologies::{ontos.keys()}")


if __name__ == "__main__":
    main()
